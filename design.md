# Mini SIP Tracker: System Design Document

This document outlines the design for a backend system to track Systematic Investment Plans (SIPs), addressing core features and scalability considerations for a fintech application.

## 1. Database Schema

The core data entities are Users and SIP Plans. For a real-time NAV integration and portfolio analytics, additional tables would be necessary.

### 1.1 Users (Supabase Auth)
Supabase handles user management and authentication. We only need to reference the `user_id` (UUID) in our application's tables.

* **`users` (managed by Supabase Auth)**
    * `id`: UUID (Primary Key, provided by Supabase Auth)
    * `email`: text
    * `created_at`: timestamp

### 1.2 SIP Plans

* **`sips` table**
    * `id`: UUID (Primary Key, generated by application or DB)
    * `user_id`: UUID (Foreign Key to `users.id`, ensures multi-tenancy)
    * `scheme_name`: text (e.g., "Parag Parikh Flexi Cap") **<-- CURRENTLY USING TEXT**
    * `monthly_amount`: numeric (amount invested monthly)
    * `start_date`: date (SIP start date)
    * `created_at`: timestamp with timezone (Defaults to current timestamp)
    * `updated_at`: timestamp with timezone (Updates on record modification)

    *Self-Correction Note*: While `scheme_name` is used here to align with the assignment's explicit API request body for the "mini" solution, for a fully normalized and scalable system (especially with future real-time NAV integration), `scheme_name` in this table should ideally be replaced with a `scheme_id` (UUID or unique identifier like ISIN) that serves as a Foreign Key to the `mutual_fund_schemes` table. This ensures data integrity, reduces redundancy, and optimizes joins for comprehensive portfolio tracking.

### 1.3 (Future) NAV Data (for real-time tracking)

* **`mutual_fund_schemes` table**
    * `id`: UUID (Primary Key)
    * `isin`: text (Unique identifier for the scheme)
    * `scheme_name`: text (Official scheme name)
    * `amc`: text (Asset Management Company)
    * `last_nav_update`: timestamp with timezone

* **`daily_navs` table**
    * `id`: UUID (Primary Key)
    * `scheme_id`: UUID (Foreign Key to `mutual_fund_schemes.id`)
    * `nav_date`: date (Date for which NAV is recorded)
    * `nav_value`: numeric
    * `created_at`: timestamp with timezone

### 1.4 (Future) SIP Transactions (for detailed execution tracking)

* **`sip_transactions` table**
    * `id`: UUID (Primary Key)
    * `user_id`: UUID (Foreign Key to `users.id`, for direct user filtering and RLS)
    * `sip_id`: UUID (Foreign Key to `sips.id`)
    * `transaction_date`: date (Date of actual SIP deduction/unit allocation)
    * `amount_invested`: numeric (Actual amount invested for that month)
    * `units_allotted`: numeric (Units purchased for that transaction)
    * `nav_at_allotment`: numeric (NAV on the transaction date)
    * `created_at`: timestamp with timezone

## 2. APIs and Endpoints

### 2.1 Current Endpoints

* `POST /sips/`
    * **Request Body**: `{ "scheme_name": "string", "monthly_amount": number, "start_date": "YYYY-MM-DD" }`
    * **Description**: Creates a new SIP plan for the authenticated user.
    * **Authentication**: Required (JWT).
    * **Authorization**: User can only create SIPs for themselves.

* `GET /sips/summary`
    * **Response Body**: `[ { "scheme_name": "string", "total_invested": number, "months_invested": number } ]`
    * **Description**: Returns a summary of all SIPs for the authenticated user, grouped by scheme, with calculated total invested amount and months invested.
    * **Authentication**: Required (JWT).
    * **Authorization**: User can only view their own SIP summaries.

### 2.2 Future Endpoints (for scaling and new features)

* `GET /schemes/search?q={query}`: Search for mutual fund schemes.
* `GET /schemes/{scheme_id}/navs`: Get historical NAVs for a specific scheme.
* `GET /sips/{sip_id}/transactions`: Get detailed transaction history for a specific SIP.
* `GET /portfolio/current_value`: Calculate and return the current portfolio value.
* `GET /portfolio/analytics`: Provide data for portfolio graphs (e.g., scheme-wise performance, XIRR).

## 3. Caching

With 10 million users and real-time data, caching becomes critical for performance.

* **User-Specific Data (e.g., SIP Summary, Portfolio Value)**:
    * **Strategy**: Use an in-memory cache (e.g., Redis) or a distributed cache like Memcached.
    * **Implementation**: Cache results of `GET /sips/summary` and `GET /portfolio/*` endpoints. Cache invalidation strategies:
        * **Time-based**: Cache expires after a few minutes (e.g., 5-15 mins).
        * **Event-driven**: Invalidate cache for a user when they create/update/delete a SIP.
    * **Considerations**: Store cache data with `user_id` as part of the key to ensure multi-tenancy.

* **Public/Shared Data (e.g., Mutual Fund Scheme List, Historical NAVs)**:
    * **Strategy**: CDN for static assets (if any). Redis for frequently accessed scheme metadata and daily NAVs.
    * **Implementation**: Cache `GET /schemes/search` results and `GET /schemes/{scheme_id}/navs`. Invalidate daily NAVs cache after new NAVs are fetched (e.g., once a day).

## 4. Background Tasks

Background tasks are essential for processing data asynchronously and handling scheduled events.

* **Real-time NAV Integration**:
    * **Task**: Periodically (e.g., daily after market close) fetch NAVs from external APIs (e.g., AMFI India) for all tracked schemes.
    * **Tool**: Celery (with Redis or RabbitMQ as a message broker) or `apscheduler` if a simpler, single-instance scheduler is sufficient initially.
    * **Process**: Fetch data, validate, store in `daily_navs` table, and update `mutual_fund_schemes.last_nav_update`.

* **Monthly SIP Execution Simulation (Bonus)**:
    * **Task**: On the first day of each month, for each active SIP, simulate a transaction.
    * **Tool**: Celery Beat (for scheduled tasks with Celery) or `apscheduler`.
    * **Process**: For each SIP, record a new entry in `sip_transactions` based on `monthly_amount` and the latest available NAV for the scheme.

* **Portfolio Analytics Calculation**:
    * **Task**: For complex portfolio calculations (e.g., XIRR, scheme performance over time), pre-calculate these metrics in the background and store them in a derived data store or cache.
    * **Tool**: Celery.
    * **Process**: Triggered on SIP creation/update, NAV updates, or periodically.

## 5. Security & Multi-tenant Architecture

### 5.1 Security

* **Supabase JWT Authentication**: Users authenticate with Supabase, which issues a JWT. This JWT is sent with every request to the FastAPI backend.
* **JWT Validation**: The FastAPI backend validates the JWT's signature (using Supabase's public key or secret), expiration, and audience.
* **User ID Injection**: A FastAPI dependency extracts the `user_id` from the validated JWT and injects it into request handlers.
* **Row-Level Security (RLS)**: Crucial for multi-tenancy. In Supabase PostgreSQL, define RLS policies on tables like `sips`, `sip_transactions` so that a user can *only* access rows where `user_id` matches their authenticated `user_id`.
    * Example Supabase RLS policy for `sips` table:
        ```sql
        CREATE POLICY "Users can view their own sips." ON sips
        FOR SELECT USING (auth.uid() = user_id);

        CREATE POLICY "Users can insert their own sips." ON sips
        FOR INSERT WITH CHECK (auth.uid() = user_id);

        CREATE POLICY "Users can update their own sips." ON sips
        FOR UPDATE USING (auth.uid() = user_id);

        CREATE POLICY "Users can delete their own sips." ON sips
        FOR DELETE USING (auth.uid() = user_id);
        ```
    * Example Supabase RLS policy for `sip_transactions` table (with `user_id`):
        ```sql
        CREATE POLICY "Users can view their own sip transactions." ON sip_transactions
        FOR SELECT USING (auth.uid() = user_id);
        -- Similar policies for INSERT, UPDATE, DELETE would also be added.
        ```
* **API Level Authorization**: Even with RLS, it's good practice to add checks at the API level (e.g., `if sip.user_id != current_user_id: raise HTTPException(403)`).
* **Input Validation**: Pydantic models in FastAPI automatically handle request body validation.
* **Sensitive Data**: No sensitive user financial data (like bank account numbers) should be stored directly in this system; integrate with regulated payment gateways.

### 5.2 Multi-tenant Architecture

* **Shared Database, Isolated Data**: All users share the same PostgreSQL database instance, but their data is isolated logically by the `user_id` column in each relevant table (`sips`, `sip_transactions`).
* **Enforcement**: RLS in Supabase PostgreSQL is the primary mechanism to enforce this isolation at the database level, preventing users from accidentally or maliciously accessing other users' data.
* **API Design**: All endpoints dealing with user-specific data must implicitly or explicitly filter by `user_id`.

## 6. (Bonus) Microservices Layout for Larger Scale

As the system grows, breaking it down into microservices improves scalability, maintainability, and team autonomy.

* **API Gateway (e.g., Nginx, Kong, AWS API Gateway)**:
    * Handles routing, load balancing, authentication (initial JWT validation), rate limiting, and SSL termination.

* **Authentication Service (or leverage Supabase Auth)**:
    * Responsible for user registration, login, token issuance, and perhaps managing user profiles. (Supabase already covers this effectively, so this could be externalized further).

* **SIP Management Service**:
    * Handles all SIP-related CRUD operations (`POST /sips/`, `GET /sips/summary`, `PUT /sips/{id}`, `DELETE /sips/{id}`).
    * Owns the `sips` table.

* **NAV & Scheme Data Service**:
    * Manages mutual fund scheme data and daily NAVs.
    * Responsible for integrating with external NAV APIs.
    * Owns `mutual_fund_schemes` and `daily_navs` tables.
    * Exposes endpoints like `GET /schemes/{id}`, `GET /schemes/{id}/navs`.

* **Transaction Service**:
    * Records actual SIP executions (`sip_transactions`).
    * Handles background tasks for monthly SIP deductions/unit allocations.
    * Owns the `sip_transactions` table.
    * Will likely use `user_id` for direct filtering of user transactions.

* **Portfolio Analytics Service**:
    * Aggregates data from SIP Management, NAV, and Transaction services.
    * Performs complex calculations (e.g., XIRR, current value, projected returns).
    * Might have its own dedicated data store for pre-calculated analytics results or use a distributed cache.

* **Message Broker (e.g., Kafka, RabbitMQ)**:
    * Enables asynchronous communication between services (e.g., NAV updates published by NAV Service consumed by Analytics Service).

### Deployment Considerations:

* **Containerization**: Docker for all services.
* **Orchestration**: Kubernetes for managing containerized services, auto-scaling, and self-healing.
* **Observability**: Centralized logging (ELK stack/Grafana Loki), monitoring (Prometheus/Grafana), and tracing (Jaeger).
* **Database Scaling**:
    * Read replicas for read-heavy services.
    * Sharding for truly massive data volumes, though often vertical scaling and read replicas suffice for a long time.
    * Supabase handles much of the underlying PostgreSQL scaling.
